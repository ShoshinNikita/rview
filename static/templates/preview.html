<!-- Preview -->
<style>
	.preview-wrapper {
		background-color: #00000000;
		display: none;
		grid-template-rows: auto min-content;
		height: 100vh;
		opacity: 0;
		overflow: hidden;
		position: fixed;
		padding: 3vh 5vw;
		row-gap: 10px;
		top: 0;
		width: 100%;
		z-index: -1;
	}

	.preview-wrapper.opened {
		display: grid;
		opacity: 100%;
		z-index: 3;
	}

	.preview-close-layer {
		height: 100%;
		left: 0;
		position: fixed;
		top: 0;
		width: 100%;
		z-index: -1;
	}

	.preview-wrapper.opened .preview-close-layer {
		background-color: var(--preview-background-color);
	}

	.preview {
		column-gap: 10px;
		display: grid;
		grid-template-columns: auto 300px;
		padding: 20px;
		position: relative;
		width: 100%;
	}

	.preview-content {
		background-position: 50%;
		background-repeat: no-repeat;
		background-size: contain;
		width: 100%;
		position: relative;
	}

	.preview-text {
		border: 1px solid var(--border-color);
		display: none;
		margin: 0;
		overflow-y: auto;
		padding: 5px;
		position: fixed;
		white-space: pre-wrap;
	}

	.preview-audio {
		display: none;
		left: 50%;
		position: absolute;
		top: 50%;
		transform: translate(-50%, -50%);
		width: 50%;
	}

	.switch-preview-button {
		align-items: center;
		display: flex;
		justify-content: center;
		height: 100%;
		opacity: 0.3;
		position: absolute;
		top: 50%;
		transform: translateY(-50%);
	}

	a.switch-preview-button:hover {
		text-decoration: none;
	}

	.switch-preview-button>svg {
		height: 50px;
		width: 50px;
	}

	.switch-preview-button.prev>svg {
		transform: rotate(90deg);
	}

	.switch-preview-button.next {
		right: 0;
	}

	.switch-preview-button.next>svg {
		transform: rotate(270deg);
	}

	.switch-preview-button.hidden {
		display: none;
	}

	.preview-side-panel {
		display: flex;
		flex-direction: column;
		justify-content: space-between;
	}

	.preview-file-info {
		font-size: 18px;
		word-break: break-all;
	}

	.preview-file-info>* {
		margin-bottom: 10px;
	}

	.preview-file-info-value {
		font-style: italic;
	}

	.preview-download-button {
		height: 30px;
		margin: 0 auto;
		min-height: 30px;
		min-width: 30px;
		width: 30px;
	}

	@media only screen and (max-width: 900px) {
		.preview {
			grid-template-columns: none;
			grid-template-rows: repeat(2, max-content);
			row-gap: 10px;
		}

		.preview-content {
			/* Move content to the bottom */
			grid-row-start: -1;
		}

		.preview-side-panel {
			column-gap: 10px;
			flex-direction: row;
		}

		.preview-file-info>* {
			margin-bottom: 3px;
		}

		.preview-download-button {
			margin: 0;
		}
	}
</style>

<!-- Selector -->
<style>
	.selector {
		column-gap: 5px;
		display: flex;
		margin: 0;
		overflow-x: auto;
		padding: 5px;
	}

	.selector-thumbnail-wrapper {
		border: 1px solid #00000000;
		display: inline-block;
	}

	.selector-thumbnail-wrapper:hover,
	.selector-thumbnail-wrapper.chosen {
		background-color: var(--hover-background-color);
		border: var(--hover-border);
	}

	.selector-thumbnail {
		border: 1px solid #00000000;
		display: flex;
		height: 100%;
		padding: 10px;
		width: 100%;
	}

	.selector-thumbnail img {
		align-self: center;
		box-shadow: var(--image-box-shadow);
		max-height: 100px;
		max-width: 100px;
	}

	.selector-thumbnail svg {
		align-self: center;
		height: 50px;
		width: 50px;
	}
</style>

<div class="preview-wrapper">
	<a href="#" class="preview-close-layer" title="Close Preview" onclick="closePreview(); return false"></a>

	<div class="preview card">
		<div class="preview-content">
			<a href="#" class="switch-preview-button prev" title="Previous" onclick="swipePreview(-1); return false">
				{{ embedIcon "chevron-down" }}
			</a>
			<a href="#" class="switch-preview-button next" title="Next" onclick="swipePreview(1); return false">
				{{ embedIcon "chevron-down" }}
			</a>

			<pre class="preview-text"></pre>
			<audio class="preview-audio" controls></audio>
		</div>

		<div class="preview-side-panel">
			<div class="preview-file-info">
				<div>
					<span>Filename:</span>
					<span class="preview-file-info-value" data-type="filename"></span>
				</div>
				<div>
					<span>Size:</span>
					<span class="preview-file-info-value nowrap" data-type="size"></span>
				</div>
				<div>
					<span>Mod Time:</span>
					<span class="preview-file-info-value nowrap" data-type="mod_time"></span>
				</div>
			</div>

			<a class="preview-download-button" title="Download the original file" href="" download="">
				{{ embedIcon "download" }}
			</a>
		</div>
	</div>

	<!-- TODO: reuse code from index.html? -->
	<ul class="selector card">
		{{ range .Entries }}

		{{ if .CanPreview }}
		<li id="selector-thumbnail-{{ .Filename }}" class="selector-thumbnail-wrapper">
			<a href="#" class="selector-thumbnail" title="{{ .Filename }}" onclick="updatePreview('{{ .Filename }}'); return false">
				{{ if eq .FileType "image" }}
				<img src="{{ .ThumbnailURL }}">
				{{ else }}
				{{ embedFileIcon .IconName }}
				{{ end }}
			</a>
		</li>
		{{ end }}

		{{ end }}
	</ul>
</div>

<script>
	const entries = JSON.parse(`{{ .Entries }}`).filter(v => { return v.can_preview; });

	const previewWrapper = document.getElementsByClassName("preview-wrapper")[0];
	const previewContent = document.getElementsByClassName("preview-content")[0];
	const previewText = document.getElementsByClassName("preview-text")[0];
	const previewAudio = document.getElementsByClassName("preview-audio")[0];
	const fileInfos = document.getElementsByClassName("preview-file-info-value");
	const previousPreviewButton = document.querySelector(".switch-preview-button.prev");
	const nextPreviewButton = document.querySelector(".switch-preview-button.next");

	const thumbnailIDPrefix = "selector-thumbnail-";

	// All attempts to set the right height for <pre> element using CSS have failed.
	(
		new ResizeObserver(() => {
			// Use Math.max because one button can be hidden. If both buttons are hidden, use full width.
			const halfMargin = Math.max(previousPreviewButton.clientWidth, nextPreviewButton.clientWidth);

			const rect = previewContent.getBoundingClientRect();
			previewText.style["height"] = `${rect.height}px`;
			previewText.style["top"] = `${rect.top}px`;
			previewText.style["width"] = `${rect.width - halfMargin * 2}px`;
			previewText.style["left"] = `${rect.x + halfMargin}px`;
		})
	).observe(previewContent);

	let isPreviewOpened = false;
	let currentFilename = null;
	let currentIndex = null;
	let scrollIntervalID = 0;
	let prevScrollLeft = null;

	const updatePreview = (filename) => {
		// Stop scroll animation to avoid any conflicts.
		clearInterval(scrollIntervalID);

		currentIndex = entries.findIndex(v => v.filename == filename);
		if (currentIndex === -1) {
			currentIndex = 0;
		}
		const entry = entries[currentIndex];

		// Scroll to the chosen file.
		const thumbnail = document.getElementById(thumbnailIDPrefix + entry.filename);
		const selector = thumbnail.parentElement;

		const wantScrollLeft = thumbnail.offsetLeft - selector.offsetLeft + thumbnail.clientWidth / 2 - selector.clientWidth / 2;
		if (isPreviewOpened) {
			let delta = Math.abs(selector.scrollLeft - wantScrollLeft) / 15; // total scroll time will be 150ms
			if (delta < 2) {
				delta = 2;
			}

			scrollIntervalID = setInterval(() => {
				const diff = selector.scrollLeft - wantScrollLeft;
				if (Math.abs(diff) <= delta || selector.scrollLeft === prevScrollLeft) {
					selector.scrollLeft = wantScrollLeft;
					prevScrollLeft = null;
					clearInterval(scrollIntervalID);
					return;
				}

				prevScrollLeft = selector.scrollLeft;

				if (diff > 0) {
					selector.scrollLeft -= delta;
				} else if (diff < 0) {
					selector.scrollLeft += delta;
				}
			}, 10);

		} else {
			// Don't animate scroll on the preview open.
			selector.scrollLeft = wantScrollLeft;
		}

		// Hide all previews.
		previewContent.style["background-image"] = "";
		previewText.style["display"] = "";
		previewAudio.style["display"] = "";

		// Update preview.
		switch (entry.file_type) {
			case "image":
				previewContent.style["background-image"] = `url(${entry.thumbnail_url})`;
				break;

			case "audio":
				previewAudio.style["display"] = "block";
				previewAudio.src = entry.original_file_url;
				break;

			case "text":
				previewText.style["display"] = "block";

				if (entry.size > 1 << 20) {
					previewText.innerHTML = `* File is too big to preview: ${entry.human_readable_size}`;
					break;
				}

				previewText.innerHTML = `* Loading "${entry.filename}"...\n`;

				let statusCode = 0;
				let textToShow = "";
				fetch(entry.original_file_url).
					then(resp => {
						statusCode = resp.status;
						return resp.text();
					}).
					then(text => textToShow = text).
					catch(err => textToShow = `${err}`).
					finally(() => {
						if (statusCode != 200) {
							textToShow = `* Error: ${textToShow}`;
						} else {
							previewText.innerHTML = "";
						}

						const escapedText = document.createTextNode(textToShow);
						previewText.appendChild(escapedText);
					});
				break;
		}

		// Update file info.
		for (const fileInfo of fileInfos) {
			const type = fileInfo.attributes["data-type"];
			switch (type.value) {
				case "filename":
					fileInfo.innerHTML = entry.filename;
					break;
				case "size":
					fileInfo.innerHTML = entry.human_readable_size;
					break;
				case "mod_time":
					fileInfo.innerHTML = entry.human_readable_mod_time;
					break;
			}
		}

		// Update link to the original file.
		const downloadButton = document.getElementsByClassName("preview-download-button")[0];
		downloadButton.href = entry.original_file_url;
		downloadButton.download = entry.filename;

		// On the first open current filename is empty.
		if (currentFilename) {
			document.getElementById(thumbnailIDPrefix + currentFilename).classList.remove("chosen");
		}
		currentFilename = entry.filename;
		document.getElementById(thumbnailIDPrefix + currentFilename).classList.add("chosen");

		// Hide switch preview buttons if necessary.
		if (currentIndex === 0) {
			previousPreviewButton.classList.add("hidden");
		} else {
			previousPreviewButton.classList.remove("hidden");
		}

		if (currentIndex === entries.length - 1) {
			nextPreviewButton.classList.add("hidden");
		} else {
			nextPreviewButton.classList.remove("hidden");
		}
	};

	const swipePreview = (direction) => {
		let newIndex = currentIndex;

		if (direction > 0) {
			newIndex++;
		} else {
			newIndex--;
		}

		if (newIndex < 0 || entries.length <= newIndex) {
			return;
		}

		updatePreview(entries[newIndex].filename);
	};

	const closePreview = () => {
		isPreviewOpened = false;

		previewWrapper.classList.remove("opened");
		document.body.classList.remove("noscroll");
	};

	// Event listeners

	window.addEventListener("keydown", (ev) => {
		if (!isPreviewOpened) {
			return;
		}

		if (ev.key === "ArrowRight") {
			swipePreview(1);

		} else if (ev.key === "ArrowLeft") {
			swipePreview(-1);

		} else if (ev.key === "Escape") {
			closePreview();
		}
	});

	const closeAnimation = "close", swipeAnimation = "swipe";

	let touchStartX = 0, touchStartY = 0, animation = "", swipeDirection = 0;

	const shouldIgnoreTouch = (ev) => {
		if (ev.touches.length > 1) {
			return true;
		}

		let ignore = ev.target !== previewContent;
		if (ignore) {
			const path = ev.path || (ev.composedPath && ev.composedPath());
			if (path) {
				for (const elem of path) {
					if (elem === previewContent) {
						ignore = false;
						break;
					}
				}
			}
		}
		return ignore;
	};

	window.addEventListener("touchstart", ev => {
		if (shouldIgnoreTouch(ev)) {
			return;
		}

		touchStartX = ev.changedTouches[0].clientX;
		touchStartY = ev.changedTouches[0].clientY;
	});
	window.addEventListener("touchmove", ev => {
		if (shouldIgnoreTouch(ev)) {
			return;
		}

		let diffX = ev.changedTouches[0].clientX - touchStartX;
		let diffY = ev.changedTouches[0].clientY - touchStartY;

		if (animation === closeAnimation || (!animation && Math.abs(diffY) > 20)) {
			animation = closeAnimation;

			if (diffY > 0) {
				diffY = 0;
			}
			const maxDiff = previewWrapper.clientHeight / 4;
			if (Math.abs(diffY) > maxDiff) {
				diffY = Math.sign(diffY) * maxDiff;
			}

			previewWrapper.style["top"] = `${diffY / 2}px`;
		}
		if (animation === swipeAnimation || (!animation && Math.abs(diffX) > 30)) {
			animation = swipeAnimation;

			const maxDiff = previewContent.clientWidth / 2;
			if (Math.abs(diffX) > maxDiff) {
				diffX = Math.sign(diffX) * maxDiff;
			}
			if ((currentIndex === 0 && diffX > 0) || (currentIndex === entries.length - 1 && diffX < 0)) {
				// Don't scroll first and last previews.
				diffX = 0;
			}

			previewContent.style["background-position-x"] = `calc(50% + ${diffX / 2}px)`;
		}
	});
	window.addEventListener("touchend", ev => {
		if (shouldIgnoreTouch(ev)) {
			return;
		}

		// Reset all changes.
		previewWrapper.style.removeProperty("top");
		//
		previewContent.style.removeProperty("background-position-x");

		const diffX = ev.changedTouches[0].clientX - touchStartX;
		const diffY = ev.changedTouches[0].clientY - touchStartY;
		switch (animation) {
			case swipeAnimation:
				if (Math.abs(diffX) > previewContent.clientWidth / 5) {
					swipePreview(-diffX);
				}
				break;

			case closeAnimation:
				if (diffY < 0 && Math.abs(diffY) > previewWrapper.clientHeight / 5) {
					closePreview();
				}
				break;
		}

		touchStartX = 0;
		touchStartY = 0;
		animation = "";
		swipeDirection = 0;
	});
</script>

<!-- Exported API -->
<script>
	window.addEventListener("preview.open", ev => {
		updatePreview(ev.detail.filename);

		if (!isPreviewOpened) {
			isPreviewOpened = true;
		}

		document.body.classList.add("noscroll");
		previewWrapper.classList.add("opened");
	});
</script>