<!-- Preview -->
<style>
	.preview-wrapper {
		background-color: #00000000;
		display: grid;
		grid-template-rows: auto min-content;
		height: 100vh;
		opacity: 0;
		overflow: hidden;
		position: fixed;
		padding: 3vh 5vw 4vh;
		row-gap: 10px;
		top: 0;
		width: 100%;
		z-index: -1;
	}

	.preview-wrapper.opened {
		opacity: 100%;
		z-index: 3;
	}

	.preview-close-layer {
		height: 100%;
		left: 0;
		position: fixed;
		top: 0;
		width: 100%;
		z-index: -1;
	}

	.preview-wrapper.opened .preview-close-layer {
		background-color: var(--preview-background-color);
	}

	.preview {
		column-gap: 10px;
		display: grid;
		grid-template-columns: auto 300px;
		padding: 20px;
		position: relative;
		width: 100%;
	}

	.preview-image {
		background-position: 50%;
		background-repeat: no-repeat;
		background-size: contain;
		width: 100%;
	}

	.preview-side-panel {
		display: flex;
		flex-direction: column;
		justify-content: space-between;
	}

	.preview-file-info {
		font-size: 18px;
		word-break: break-all;
	}

	.preview-file-info>* {
		margin-bottom: 10px;
	}

	.preview-file-info-value {
		font-style: italic;
	}

	.preview-download-button {
		height: 30px;
		margin: 0 auto;
		min-height: 30px;
		min-width: 30px;
		width: 30px;
	}

	.preview-download-button svg {
		height: 100%;
		width: 100%;
	}

	@media only screen and (max-width: 900px) {
		.preview {
			grid-template-columns: none;
			grid-template-rows: repeat(2, max-content);
			row-gap: 10px;
		}

		.preview-image {
			/* Move image to the bottom */
			grid-row-start: -1;
		}

		.preview-side-panel {
			column-gap: 10px;
			flex-direction: row;
		}

		.preview-file-info>* {
			margin-bottom: 3px;
		}

		.preview-download-button {
			margin: 0;
		}
	}
</style>

<!-- Selector -->
<style>
	.selector {
		column-gap: 5px;
		display: flex;
		margin: 0;
		overflow-x: auto;
		padding: 5px;
	}

	.selector-thumbnail-wrapper {
		border: 1px solid #00000000;
		display: inline-block;
	}

	.selector-thumbnail-wrapper:hover,
	.selector-thumbnail-wrapper.chosen {
		background-color: var(--hover-background-color);
		border: var(--hover-border);
	}

	.selector-thumbnail {
		border: 1px solid #00000000;
		display: flex;
		height: 100%;
		padding: 10px;
		width: 100%;
	}

	.selector-thumbnail img {
		align-self: center;
		box-shadow: var(--image-box-shadow);
		max-height: 100px;
		max-width: 100px;
	}
</style>

<div class="preview-wrapper">
	<a href="#" class="preview-close-layer" title="Close Preview" onclick="closePreview()"></a>

	<div class="preview card">
		<div class="preview-image"></div>

		<div class="preview-side-panel">
			<div class="preview-file-info">
				<div>
					<span>Filename:</span>
					<span class="preview-file-info-value" data-type="filename"></span>
				</div>
				<div>
					<span>Size:</span>
					<span class="preview-file-info-value nowrap" data-type="size"></span>
				</div>
				<div>
					<span>Mod Time:</span>
					<span class="preview-file-info-value nowrap" data-type="mod_time"></span>
				</div>
			</div>

			<a class="preview-download-button" title="Download the original file" href="" download="">
				{{ embedIcon "download" }}
			</a>
		</div>
	</div>

	<ul class="selector card">
		{{ range .Entries }}

		{{ if not .ThumbnailURL }}
		{{ continue }}
		{{ end }}

		<li id="selector-thumbnail-{{ .Filename }}" class="selector-thumbnail-wrapper">
			<a href="#" class="selector-thumbnail" title="{{ .Filename }}" onclick="updatePreview('{{ .Filename }}')">
				<img src="{{ .ThumbnailURL }}">
			</a>
		</li>

		{{ end }}
	</ul>
</div>

<script>
	const entries = JSON.parse(`{{ .Entries }}`).filter(v => { return v.thumbnail_url; });

	const previewWrapper = document.getElementsByClassName("preview-wrapper")[0];
	const previewImage = document.getElementsByClassName("preview-image")[0];
	const fileInfos = document.getElementsByClassName("preview-file-info-value");

	const thumbnailIDPrefix = "selector-thumbnail-";

	let isPreviewOpened = false;
	let currentFilename = null;
	let scrollIntervalID = 0;
	let prevScrollLeft = null;

	const updatePreview = (filename) => {
		// Stop scroll animation to avoid any conflicts.
		clearInterval(scrollIntervalID);

		const entry = entries.find(v => v.filename == filename) || entries[0];

		// Scroll to the chosen file.
		const thumbnail = document.getElementById(thumbnailIDPrefix + entry.filename);
		const selector = thumbnail.parentElement;

		const wantScrollLeft = thumbnail.offsetLeft - selector.offsetLeft + thumbnail.clientWidth / 2 - selector.clientWidth / 2;
		if (isPreviewOpened) {
			let delta = Math.abs(selector.scrollLeft - wantScrollLeft) / 15; // total scroll time will be 150ms
			if (delta < 2) {
				delta = 2;
			}

			scrollIntervalID = setInterval(() => {
				const diff = selector.scrollLeft - wantScrollLeft;
				if (Math.abs(diff) <= delta || selector.scrollLeft === prevScrollLeft) {
					selector.scrollLeft = wantScrollLeft;
					prevScrollLeft = null;
					clearInterval(scrollIntervalID);
					return;
				}

				prevScrollLeft = selector.scrollLeft;

				if (diff > 0) {
					selector.scrollLeft -= delta;
				} else if (diff < 0) {
					selector.scrollLeft += delta;
				}
			}, 10);

		} else {
			// Don't animate scroll on the preview open.
			selector.scrollLeft = wantScrollLeft;
		}

		// Update preview.
		previewImage.style["background-image"] = `url(${entry.thumbnail_url})`;

		// Update file info.
		for (const fileInfo of fileInfos) {
			const type = fileInfo.attributes["data-type"];
			switch (type.value) {
				case "filename":
					fileInfo.innerHTML = entry.filename;
					break;
				case "size":
					fileInfo.innerHTML = entry.human_readable_size;
					break;
				case "mod_time":
					fileInfo.innerHTML = entry.human_readable_mod_time;
					break;
			}
		}

		// Update link to the original file.
		const downloadButton = document.getElementsByClassName("preview-download-button")[0];
		downloadButton.href = entry.original_file_url;
		downloadButton.download = entry.filename;

		// On the first open current filename is empty.
		if (currentFilename) {
			document.getElementById(thumbnailIDPrefix + currentFilename).classList.remove("chosen");
		}
		currentFilename = entry.filename;
		document.getElementById(thumbnailIDPrefix + currentFilename).classList.add("chosen");
	};

	const swipePreview = (direction) => {
		let newIndex = entries.findIndex(v => v.filename === currentFilename);
		if (newIndex === -1) {
			newIndex = 0;
		}

		if (direction > 0) {
			newIndex++;
		} else {
			newIndex--;
		}

		if (newIndex < 0) {
			newIndex = 0;
		}
		if (newIndex >= entries.length) {
			newIndex = entries.length - 1;
		}

		updatePreview(entries[newIndex].filename);
	};

	const closePreview = () => {
		isPreviewOpened = false;

		previewWrapper.classList.remove("opened");
		document.body.classList.remove("noscroll");
	};

	// Event listeners

	window.addEventListener("keydown", (ev) => {
		if (!isPreviewOpened) {
			return;
		}

		if (ev.key === "ArrowRight") {
			swipePreview(1);

		} else if (ev.key === "ArrowLeft") {
			swipePreview(-1);

		} else if (ev.key === "Escape") {
			closePreview();
		}
	});

	const closeAnimation = "close", swipeAnimation = "swipe";

	let touchStartX = 0, touchStartY = 0, animation = "", swipeDirection = 0;

	const shouldIgnoreTouch = (ev, ignoreTouchStarts = false) => {
		let ignore = ev.target !== previewImage || ev.touches.length > 1;
		if (!ignoreTouchStarts) {
			ignore = ignore || !(touchStartX && touchStartY);
		}
		return ignore;
	};

	window.addEventListener("touchstart", ev => {
		if (shouldIgnoreTouch(ev, true)) {
			return;
		}

		touchStartX = ev.changedTouches[0].clientX;
		touchStartY = ev.changedTouches[0].clientY;
	});
	window.addEventListener("touchmove", ev => {
		if (shouldIgnoreTouch(ev)) {
			return;
		}

		let diffX = ev.changedTouches[0].clientX - touchStartX;
		let diffY = ev.changedTouches[0].clientY - touchStartY;

		if (Math.abs(diffY) > 30 && (!animation || animation === closeAnimation)) {
			animation = closeAnimation;

			if (diffY > 0) {
				diffY = 0;
			}

			previewWrapper.style["top"] = `${diffY / 3}px`;
			previewWrapper.style["opacity"] = `${100 - (Math.abs(diffY) / previewWrapper.clientHeight * 100) / 3}%`;
		}
		if (Math.abs(diffX) > 30 && (!animation || animation === swipeAnimation)) {
			animation = swipeAnimation;

			previewImage.style["background-position-x"] = `calc(50% + ${diffX / 3}px)`;
		}
	});
	window.addEventListener("touchend", ev => {
		if (shouldIgnoreTouch(ev)) {
			return;
		}

		// Reset all changes.
		previewWrapper.style.removeProperty("top");
		previewWrapper.style.removeProperty("opacity");
		//
		previewImage.style.removeProperty("background-position-x");

		const diffX = ev.changedTouches[0].clientX - touchStartX;
		const diffY = ev.changedTouches[0].clientY - touchStartY;
		switch (animation) {
			case swipeAnimation:
				if (Math.abs(diffX) > previewImage.clientWidth / 4) {
					swipePreview(-diffX);
				}
				break;

			case closeAnimation:
				if (diffY < 0 && Math.abs(diffY) > previewWrapper.clientHeight / 3) {
					closePreview();
				}
				break;
		}

		touchStartX = 0;
		touchStartY = 0;
		animation = "";
		swipeDirection = 0;
	});
</script>

<!-- Exported API -->
<script>
	window.addEventListener("preview.open", ev => {
		updatePreview(ev.detail.filename);

		if (!isPreviewOpened) {
			isPreviewOpened = true;
		}

		document.body.classList.add("noscroll");
		previewWrapper.classList.add("opened");
	});
</script>