<!-- Preview -->
<style>
	.preview-wrapper {
		/*
			Use "visibility: hidden" to be able to scroll selector on first open and
			to prevent all pointer events: https://stackoverflow.com/a/34529598.
		*/
		background-color: #00000000;
		display: grid;
		grid-template-rows: auto min-content;
		overflow: hidden;
		position: fixed;
		padding: 3vh 5vw;
		row-gap: 10px;
		top: 0;
		visibility: hidden;
		width: 100%;
		z-index: 3;
	}

	.preview-wrapper.opened {
		visibility: visible;
	}

	.preview-close-layer {
		height: 100%;
		left: 0;
		position: fixed;
		top: 0;
		width: 100%;
		z-index: -1;
	}

	.preview-wrapper.opened .preview-close-layer {
		background-color: var(--preview-background-color);
	}

	.preview {
		column-gap: 10px;
		display: grid;
		grid-template-columns: auto 300px;
		padding: 20px;
		position: relative;
		width: 100%;
	}

	.preview-content {
		width: 100%;
		position: relative;
	}

	.preview-image {
		display: none;
		position: fixed;
		object-fit: contain;
	}

	.preview-text {
		border: 1px solid var(--border-color);
		display: none;
		margin: 0;
		overflow-y: auto;
		padding: 5px;
		position: fixed;
		white-space: pre-wrap;
	}

	.preview-audio {
		display: none;
		left: 50%;
		position: absolute;
		top: 50%;
		transform: translate(-50%, -50%);
		width: 50%;
	}

	.preview-video {
		display: none;
		position: fixed;
		transform: translateY(-50%);
	}

	.switch-preview-button {
		align-items: center;
		display: flex;
		justify-content: center;
		height: 100%;
		opacity: 0.3;
		position: absolute;
		top: 50%;
		transform: translateY(-50%);
	}

	a.switch-preview-button:hover {
		text-decoration: none;
	}

	.switch-preview-button>svg {
		height: 50px;
		width: 50px;
	}

	.switch-preview-button.prev>svg {
		transform: rotate(90deg);
	}

	.switch-preview-button.next {
		right: 0;
	}

	.switch-preview-button.next>svg {
		transform: rotate(270deg);
	}

	.switch-preview-button.hidden {
		display: none;
	}

	.preview-side-panel {
		display: flex;
		flex-direction: column;
		justify-content: space-between;
	}

	.preview-file-info {
		font-size: 18px;
		word-break: break-all;
	}

	.preview-file-info>* {
		margin-bottom: 10px;
	}

	.preview-file-info-value {
		font-style: italic;
	}

	.preview-close-button,
	.preview-download-button {
		height: 30px;
		margin: 0 auto;
		min-height: 30px;
		min-width: 30px;
		width: 30px;
	}

	/* Display close button only on medium and small displays. */
	.preview-close-button {
		display: none;
	}

	@media only screen and (max-width: 1200px) {
		.preview {
			grid-template-columns: none;
			grid-template-rows: repeat(2, max-content);
			row-gap: 10px;
		}

		.preview-content {
			/* Move content to the bottom */
			grid-row-start: -1;
		}

		.preview-side-panel {
			display: grid;
			grid-template:
				"file-info close-button"
				"file-info download-button";
			column-gap: 10px;
			flex-direction: row;
		}

		.preview-file-info {
			grid-area: file-info;
		}

		.preview-file-info>* {
			margin-bottom: 3px;
		}

		.preview-close-button,
		.preview-download-button {
			margin: 0;
		}

		.preview-close-button {
			display: block;
		}

		.preview-download-button {
			align-self: end;
			grid-area: download-button;
		}

		.preview-close-button {
			grid-area: close-button;
		}
	}

	@media only screen and (max-width: 600px) {
		.preview-wrapper {
			padding: 0;
		}

		.preview-close-layer {
			pointer-events: none;
		}

		.preview {
			padding-left: 0;
			padding-right: 0;
		}

		.preview-side-panel {
			padding-left: 20px;
			padding-right: 20px;
		}
	}
</style>

<!-- Selector -->
<style>
	.selector {
		column-gap: 10px;
		display: grid;
		grid-auto-columns: 120px;
		grid-auto-flow: column;
		margin: 0;
		overflow-x: auto;
		padding: 5px;
		scroll-behavior: smooth;
	}

	.selector-thumbnail-wrapper {
		display: contents;
	}

	.selector-thumbnail-wrapper .thumbnail {
		max-height: 100px;
	}

	.selector-thumbnail-wrapper .icon {
		height: 50px;
		width: 50px;
	}
</style>

<div class="preview-wrapper">
	<a href="#" class="preview-close-layer" title="Close Preview" onclick="closePreview(); return false"></a>

	<div class="preview card">
		<div class="preview-content">
			<a href="#" class="icon-button switch-preview-button prev" title="Previous" onclick="swipePreview(-1); return false">
				{{ embedIcon "chevron-down" }}
			</a>
			<a href="#" class="icon-button switch-preview-button next" title="Next" onclick="swipePreview(1); return false">
				{{ embedIcon "chevron-down" }}
			</a>

			<!-- TODO: add loader -->

			<img class="preview-image"></img>
			<pre class="preview-text"></pre>
			<audio class="preview-audio" controls></audio>
			<video class="preview-video" controls></video>
		</div>

		<div class="preview-side-panel">
			<div class="preview-file-info">
				<div>
					<span>Filename:</span>
					<span class="preview-file-info-value" data-type="filename"></span>
				</div>
				<div>
					<span>Size:</span>
					<span class="preview-file-info-value nowrap" data-type="size"></span>
				</div>
				<div>
					<span>Mod Time:</span>
					<span class="preview-file-info-value nowrap" data-type="mod_time"></span>
				</div>
			</div>

			<a class="icon-button preview-close-button" title="Close Preview" onclick="closePreview(); return false">
				{{ embedIcon "x" }}
			</a>

			<a class="icon-button preview-download-button" title="Download the original file" href="" download="">
				{{ embedIcon "download" }}
			</a>
		</div>
	</div>

	<ul class="selector card">
		{{ range .Entries }}

		{{ if .CanPreview }}
		<div id="selector-thumbnail-{{ .Filename }}" class="selector-thumbnail-wrapper">
			{{
				template "entry.html" (dict
					"Entry" .
					"Href" "#"
					"Title" .Filename
					"Onclick" (printf `updatePreview('%s'); return false` .Filename)
				)
			}}
		</div>
		{{ end }}

		{{ end }}
	</ul>
</div>

<script>
	const entries = JSON.parse(`{{ .Entries }}`).filter(v => { return v.can_preview; });

	const previewWrapper = document.getElementsByClassName("preview-wrapper")[0];
	const previewContent = document.getElementsByClassName("preview-content")[0];
	const previewImage = document.getElementsByClassName("preview-image")[0];
	const previewText = document.getElementsByClassName("preview-text")[0];
	const previewAudio = document.getElementsByClassName("preview-audio")[0];
	const previewVideo = document.getElementsByClassName("preview-video")[0];
	const fileInfos = document.getElementsByClassName("preview-file-info-value");
	const previousPreviewButton = document.querySelector(".switch-preview-button.prev");
	const nextPreviewButton = document.querySelector(".switch-preview-button.next");

	const thumbnailIDPrefix = "selector-thumbnail-";

	// All attempts to set the right height for <pre> element using CSS have failed.
	(
		new ResizeObserver(() => {
			// Use Math.max because one button can be hidden. If both buttons are hidden, use full width.
			const halfMargin = Math.max(previousPreviewButton.clientWidth, nextPreviewButton.clientWidth);

			const rect = previewContent.getBoundingClientRect();

			for (const v of [previewImage, previewText, previewVideo]) {
				v.style["height"] = `${rect.height}px`;
				v.style["top"] = `${rect.top}px`;
				v.style["width"] = `${rect.width - halfMargin * 2}px`;
				v.style["left"] = `${rect.x + halfMargin}px`;
			}

			// Set "max-height" instead of "height" to avoid gap between controls and video.
			previewVideo.style["height"] = "";
			previewVideo.style["max-height"] = `${rect.height}px`;
			// Center video vertically. Height of the video is taken into account by "translateY";
			previewVideo.style["top"] = `${rect.top + rect.height / 2}px`;
		})
	).observe(previewContent);

	// Set height of .preview-wrapper with JS as a workaround for this bug:
	// https://bugzilla.mozilla.org/show_bug.cgi?id=1663634
	//
	// We can't use ResizeObserver because we want to get resize events for the window.
	//
	// More about mobile browser URL bars: https://github.com/bokand/URLBarSizing.
	const changePreviewWindowHeightOnResize = () => {
		previewWrapper.style["height"] = `${window.innerHeight}px`;
	};
	window.addEventListener("resize", changePreviewWindowHeightOnResize);
	window.addEventListener("load", changePreviewWindowHeightOnResize);

	const stopAnyPlayback = () => {
		for (const v of [previewAudio, previewVideo]) {
			v.pause();
			v.currentTime = 0;
		}
	};

	let isPreviewOpened = false;
	let currentFilename = null;
	let currentIndex = null;
	let prevScrollLeft = null;

	const updatePreview = (filename) => {
		if (currentFilename === filename) {
			return;
		}

		currentIndex = entries.findIndex(v => v.filename == filename);
		if (currentIndex === -1) {
			currentIndex = 0;
		}
		const entry = entries[currentIndex];

		// Scroll to the chosen file.
		const thumbnailWrapper = document.getElementById(thumbnailIDPrefix + entry.filename);
		const thumbnail = thumbnailWrapper.children[0];
		const selector = thumbnailWrapper.parentElement;

		selector.scrollLeft = thumbnail.offsetLeft - selector.offsetLeft + thumbnail.clientWidth / 2 - selector.clientWidth / 2;;

		// Hide all previews.
		previewImage.style["display"] = "";
		previewText.style["display"] = "";
		previewAudio.style["display"] = "";
		previewVideo.style["display"] = "";

		stopAnyPlayback();

		// Update preview.
		switch (entry.file_type) {
			case "image":
				previewImage.style["display"] = "block";
				previewImage.src = entry.thumbnail_url;
				break;

			case "audio":
				previewAudio.style["display"] = "block";
				previewAudio.src = entry.original_file_url;
				break;

			case "video":
				previewVideo.style["display"] = "block";
				previewVideo.src = entry.original_file_url;
				break;

			case "text":
				previewText.style["display"] = "block";

				if (entry.size > 1 << 20) {
					previewText.innerHTML = `* File is too big to preview: ${entry.human_readable_size}`;
					break;
				}

				previewText.innerHTML = `* Loading "${entry.filename}"...\n`;

				let statusCode = 0;
				let textToShow = "";
				fetch(entry.original_file_url).
					then(resp => {
						statusCode = resp.status;
						return resp.text();
					}).
					then(text => textToShow = text).
					catch(err => textToShow = `${err}`).
					finally(() => {
						if (statusCode != 200) {
							textToShow = `* Error: ${textToShow}`;
						} else {
							previewText.innerHTML = "";
						}

						const escapedText = document.createTextNode(textToShow);
						previewText.appendChild(escapedText);
					});
				break;
		}

		// Update file info.
		for (const fileInfo of fileInfos) {
			const type = fileInfo.attributes["data-type"];
			switch (type.value) {
				case "filename":
					fileInfo.innerHTML = entry.filename;
					break;
				case "size":
					fileInfo.innerHTML = entry.human_readable_size;
					break;
				case "mod_time":
					fileInfo.innerHTML = entry.human_readable_mod_time;
					break;
			}
		}

		// Update link to the original file.
		const downloadButton = document.getElementsByClassName("preview-download-button")[0];
		downloadButton.href = entry.original_file_url;
		downloadButton.download = entry.filename;

		// On the first open current filename is empty.
		if (currentFilename) {
			document.getElementById(thumbnailIDPrefix + currentFilename).classList.remove("selected");
		}
		currentFilename = entry.filename;
		document.getElementById(thumbnailIDPrefix + currentFilename).classList.add("selected");

		// Hide switch preview buttons if necessary.
		if (currentIndex === 0) {
			previousPreviewButton.classList.add("hidden");
		} else {
			previousPreviewButton.classList.remove("hidden");
		}

		if (currentIndex === entries.length - 1) {
			nextPreviewButton.classList.add("hidden");
		} else {
			nextPreviewButton.classList.remove("hidden");
		}

		setPreviewInQuery(filename);
	};

	const swipePreview = (direction) => {
		let newIndex = currentIndex;

		if (direction > 0) {
			newIndex++;
		} else {
			newIndex--;
		}

		if (newIndex < 0 || entries.length <= newIndex) {
			return;
		}

		updatePreview(entries[newIndex].filename);
	};

	const closePreview = () => {
		stopAnyPlayback();
		setPreviewInQuery("");

		isPreviewOpened = false;

		previewWrapper.classList.remove("opened");
		document.body.classList.remove("noscroll");
	};

	const setPreviewInQuery = (filename) => {
		const params = new URLSearchParams(window.location.search);
		const firstTime = !params.get("preview");
		if (filename) {
			params.set("preview", filename);
		} else {
			params.delete("preview");
		}

		const currentPath = window.location.pathname + window.location.search;
		const encodedParams = params.toString();
		const newPath = window.location.pathname + (encodedParams ? "?" + encodedParams : "");
		if (currentPath === newPath) {
			return;
		}

		// Use History API to avoid page reload: https://stackoverflow.com/a/41542008.
		if (firstTime) {
			// Push state for first preview.
			history.pushState(null, "", newPath);
		} else {
			// Replace state because we don't want to create a new history entry for every preview.
			history.replaceState(null, "", newPath);
		}
	};

	// Event listeners

	window.addEventListener("popstate", (ev) => {
		// Close preview on "Go back".
		const params = new URLSearchParams(window.location.search);
		if (!params.get("preview")) {
			closePreview();
		}
	});


	window.addEventListener("keydown", (ev) => {
		if (!isPreviewOpened) {
			return;
		}

		if (ev.key === "ArrowRight") {
			swipePreview(1);

		} else if (ev.key === "ArrowLeft") {
			swipePreview(-1);

		} else if (ev.key === "Escape") {
			closePreview();
		}
	});
</script>

<!-- Exported API -->
<script>
	window.addEventListener("preview.open", ev => {
		const filename = ev.detail.filename;

		const index = entries.findIndex(v => v.filename == filename);
		if (index === -1) {
			console.warn(`can't open preview for "${filename}": no such file`);
			return;
		}

		updatePreview(filename);

		if (!isPreviewOpened) {
			isPreviewOpened = true;
		}

		document.body.classList.add("noscroll");
		previewWrapper.classList.add("opened");
	});
</script>